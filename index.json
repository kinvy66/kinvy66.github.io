[{"categories":["Java"],"content":"Java基础语法 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1. 注释、标识符、关键字 Java的注释有三种：(单行注释，多行注释) public class HelloWorld { public static void main(String[] args) { //1.单行注释 System.out.println(\"Hello,World!\"); /*2.多行 注释 */ //JavaDoc：文档注释 /** * @Description com.kinvy.base.HelloWorld * @Author Kinvy */ } } 标识符 关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符 标识符的规则：以字母，$,下划线开始，不能使用关键字或保留字 基本的命名规则和C/C++一致 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2. 数据类型 Java是强类型语言，即所有的变量必须先定义后才能使用 Java的数据类型分为两大类 基本类型 数值类型：整数类型(int shor byte long ),浮点型(float double) 字符类型(char 占两个字节) boolean类型 引用类型 类，接口，数组 说明：string 是类 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3类型转换 语法：(转换类型)变量名 public class HelloWorld { public static void main(String[] args) { char c1 = 'a'; System.out.println(c1); System.out.println(int(c1)); //char--\u003eint } } 低———————————————————————–高 byte -\u003e short -\u003e char -\u003e int -\u003e long -\u003e flaot -\u003e double 说明：强制转换可能存在精度丢失，自动转换（低–\u003e高） ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 常量、变量 命名规则： 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Person，GoodMan 方法名：首字母小写和驼峰原则：run() , startTask() 方法形参：下划线开始，首字母大写和驼峰原则： _Pos c++ ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5. 运算符 Java支持的运算符：常规运算符都支持 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"6. 包机制 包语句的语法格式： package pkg1[. pkg2[.pkg3..]] 导入包的语法： import package1[.package2..].classname|* package com.kinvy.array; //包 import java.util.Arrays; //导入Arrays的包 public class ArrayDemo01 { public static void main(String[] args) { int[] a = {1,2,3,4,9090,324,5412,122,3}; System.out.println(a); //打印数组元素 System.out.println(Arrays.toString((a))); } } 说明：一般利用公司域名倒置作为包名 com.baidu.www ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:6","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java流程控制（顺序，循环，选择） 参照C++流程控制语法 用户交互Scanner package com.kinvy.base; import java.util.Scanner; public class Demo02 { public static void main(String[] args) { //创建一个扫描器对象 Scanner scanner = new Scanner(System.in); System.out.println(\"使用next():\"); //判断用户有没有输入字符 if(scanner.hasNext()) { String str = scanner.next(); System.out.println(\"输出内容为：\"+str); } //scanner.close(); //用完管关掉，不关会一致占用资源 /**********************************/ scanner = new Scanner(System.in); System.out.println(\"使用nextline():\"); if(scanner.hasNextLine()) { String str1 = scanner.nextLine(); System.out.println(\"输出内容：\"+str1); } scanner.close(); int i = 0; System.out.println(\"输入整数：\"); if(scanner.hasNextInt()) { i = scanner.nextInt(); System.out.println(\"整数数据:\"+i); } else { System.out.println(\"输入的不是整数数据！\"); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:2:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java方法 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1.方法是什么 Java中的方法和C++中类的成员函数一致，用来完成特定功能的代码片段 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2.方法的定义 /* 修饰符 返回值类型 方法名（参数类型 参数名） { 方法体 return 返回值; } */ //方法是定义在class中的 public class Demo { public static void main(String[] args) { System.out.println(\"Hello,World!\"); int ret = add(10,20); //方法调用 System.out.println(ret); } //方法定义 public static int add(int num1,int num2) { return num1+num2; } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3.方法的重载 方法重载的规则： 方法名称必须相同 参数列表必须不同（个数不同，或类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不同 返回值类型不同不能作为重载的条件 public class Demo { public static void main(String[] args) { System.out.println(\"Hello,World!\"); int ret = add(10,20); //方法调用 System.out.println(ret); float f = add(1.2f,1.4f); System.out.println(f); } //方法定义 public static int add(int num1,int num2) { return num1+num2; } //重载方法 public static float add(float num1,float num2) { return num1+num2; } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 命令行传递参数 示例： //该程序需要在命令行运行 public class Demo01 { public static void main(String[] args) { for (int i = 0; i \u003c args.length; i++) { System.out.println(\"args[\"+i+\"]:\"+args[i]); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5.可变参数 JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 public class Demo02 { public static void main(String[] args) { Demo02 demo02 = new Demo02(); demo02.method(12,43,54,12,56,35); } public static void method(int... number) { System.out.println(number); //输出的是一个对象地址 for (int i = 0; i \u003c number.length; i++) { System.out.println(number[i]); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java OOP ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1. 初识面向对象 以类的形式组织代码，以对象的组织（封装）数据。 面向对象特征：封装，继承，多态 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2. 方法 定义一个 方法： 修饰符 返回值类型 方法名(…) { ​ 方法体 ​ return 返回值； } 示例： public class Demo01 { public static void main(String[] args) { //int max = max(129, 12); } public static String sayHello() { return \"hello\"; } public int max(int a, int b) { return a\u003eb ? a : b; } } 方法的调用 //Demo02.java public class Demo02 { public static void main(String[] args) { //非静态方法实例化这个类 Student student = new Student(); student.speak(); //静态方法 static Student.say(); } } //Student.java public class Student { //非静态方法 public void speak() { System.out.println(\"speak\"); } //静态方法 public static void say() { System.out.println(\"say\"); } } 说明：java方法的参数传递是值传递， ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3. 对象的创建 使用new创建对象，示例同上 构造器 构造器和c++中的构造函数一致 无参构造，有参构造，定义了有参构造，无参构造必须显示定义 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 面向对象三大特性 封装： 继承： Java只有单继承，没有多继承 在java中所有的类都默认直接或间接继承Object类 调用父类的同名属性和方法使用super 关键字 /************ Application.java **************/ package com.kinvy.oop; import com.kinvy.oop.demo02.Student; public class Application { public static void main(String[] args) { Student student = new Student(); student.test(\"App\"); } } /************* Person.java 父类 **************/ package com.kinvy.oop.demo02; //父类 Person public class Person { public Person() { } public String name = \"Person\"; } /********* Student.java 子类继承自Person ***********/ package com.kinvy.oop.demo02; //子类 继承自Person public class Student extends Person { //继承自Person public String name = \"Student\"; public void test(String name) { System.out.println(name); //输出的是传进来的name值 System.out.println(this.name); //输出当前类的name = Student System.out.println(super.name); //输出父类的name = Person } } 子类实例化时会自动调用父类的构造器，隐藏式的调用super()； super()注意点： super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或构造方法中 super和this不能同时调用构造方法 VS this 代表的对象不同： ​ this: 本身调用者这个对象 ​ super：代表父类对象的引用 前提： ​ this： 没有继承也可以使用 ​ super： 只能在继承条件才可以使用 构造方法： ​ this() ：本类的构造 ​ super()： 父类的构造 方法的重写 /************ Application.java **************/ package com.kinvy.oop; import com.kinvy.oop.demo02.Son; import com.kinvy.oop.demo02.Base; public class Application { public static void main(String[] args) { Son son = new Son(); Base base = new Son(); //静态方法 son.test01(); //调用子类 base.test01(); //调用父类 System.out.println(\"------------------\"); //非静态方法 son.test02(); //调用子类 base.test02(); //调用父类 } } /************* Base.java 父类 **************/ package com.kinvy.oop.demo02; public class Base { public static void test01() { System.out.println(\"Base test01()\"); } public void test02() { System.out.println(\"Base test02()\"); } } /********* Son.java 子类继承自Person ***********/ package com.kinvy.oop.demo02; public class Son extends Base{ public static void test01() { //静态无法重写 System.out.println(\"Son test01()\"); } @Override //重写父类非静态方法 public void test02() { System.out.println(\"Son test02()\"); } } 重写：需要有继承关系，子类重写父类的方法 方法名必须相同 参数列表必须相同 修饰符：权限范围可以扩大 但不能缩小 publi-\u003eprotected-\u003eprivate 抛出的异常：范围，可以被缩小，但不能扩大 多态： /************Application.java ******************/ package com.kinvy.oop; import com.kinvy.oop.demo03.Person; import com.kinvy.oop.demo03.Student; public class Application { public static void main(String[] args) { //一个对象的实际类型是确定的 new Student(); new Person(); //可以指向的引用类型就不确定了；父类的引用指向子类 //Student 能调用的方法都是自己的或者继承父类的 Student s1 = new Student(); //Person 父类型， 可以指向子类，当时不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); s2.run(); //子类重写了父类的方法，执行子类的方法 s1.run(); ((Student) s2).eat(); //强制装换 } } /************Person,java*************************/ package com.kinvy.oop.demo03; public class Person { public void run() { System.out.println(\"person run\"); } } /************Student.java*********************/ package com.kinvy.oop.demo03; public class Student extends Person { @Override public void run() { System.out.println(\"student run\"); } public void eat() { System.out.println(\"student eat\"); } } 多态注意事项： 多态是方法的多态，属性没有多态 父类和子类，有联系，类型转换异常 ！ ClassCast 存在条件：继承关系，方法需要重写，父类引用指向子类对象！ father f1 = new son(); ​ 不可以重写的方法： static方法 final常量 private方法 instanceof 关键字 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5. 抽象类和接口 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"6.内部类及OOP实战","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:6","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["git"],"content":"Typora+PicGo实现笔记图片上传到服务器,上传失败 Typora+PicGo实现笔记中图片上传到服务器，避免Markdown文件拷贝时图片打不开的问题 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:0:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"软件工具 系统：Windows10（macOS请参考 官方文档） Typora（版本：≥ 0.9.9.32 on macOS or 0.9.84 on Windows / Linux） PicGo（版本：≥ 2.2.0 ),在Typora软件下载（文件–\u003e偏好设置–\u003e图像） 阿里云OSS对象，（使用gitee或GitHub也可以） ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:1:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"阿里云OSS的购买和使用 购买阿里云OSS，我购买的是40GB一年的（9RMB） 在控制台找到OSS管理，创建Bucket，读写权限设置为公共读，名称按照规定任意写一个，其他设置默认就可以 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:2:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"配置PicGO 打开PicGo配置阿里云OSS 设定KeyId：在阿里云的控制台中，如下图1，没有AccessKey ID 的话可以自己创建一个，然后将 AccessKey ID 复制道KeyId 设定KeySecret：在创建的AccessKey ID中查看Secret，把它复制到设定KeySecret 设定存储空间名：Bucket的名称 确认存储区域：阿里云控制台中，图2 图1：图2： 配置PicGo的端口36677 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:3:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"Typora设置 文件–\u003e偏好设置–\u003e图像， 设置如下图 设置完毕，将图片添加到Markdown笔记中，会自动上传到服务器，图片链接也会转成一个URL 注意：PicGo的端口一定要设置正确，否则图片会上传失败 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:4:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["Git"],"content":"Git的基本使用 基本命令 git init #初始化当前文件夹作为git库 git clone #复制远程的库 #版本管理 git add #将工作区的文件放入暂存区，后面加文件名或文件 git commit #将暂存区的文件提交到库中，会弹出编辑器提示输入提交信息，适用于提交信息比较多的情况 git commit -m '提交信息' #提交文件到库中，并注明提价信息，适用提交信息比较简短的情况 git rm #删除文件 git rm --cached \u003cfile\u003e... #从暂存区删除文件 #查看信息 git help #帮助 git log #查看日志 git log -n #查看最近n条的日志 git log --pretty=oneline #一行简略的显示日志 git diff #比较不同 git status #查看文件修改状态 git config --list #查看配置信息 #远程协作 git pull git push #git配置 git config --global #使用全局配置文件 git config --system #使用系统的配置文件 git config --local #使用当前仓库的配置文件 git config --global user.name 'naem' #配置全局用户名 git config --global user.email 'email' #配置全局邮箱 #删除文件 git rm filename #删除工作区的文件， #完成了两件事，1.删除一个文件 2.将删除的文件纳入到暂存区 #从已提交的文件中恢复删除的文件 git reset HEAD filename #将待删除的文件从暂存区恢复到工作区 git checkout -- filename #把之前的修改丢弃，用 rm 删除的文件只要这个命令就可以恢复 #文件重命名 git mv oldname newname #执行这个命令后文件就会放入到暂存区，和mv的区别与 git rm和rm的区别一样 #修改上次提交的消息 git commit --amend -m '修改的消息内容' #.gitignore文件 #在目录下添加一个.gitignore文件 #文件内容就是需要忽略文件的文件名 #git上传是就会忽略这些文件 #文件支持通配符和正则表达式 分支相关命令 git branch #查看当前所有的分支 git branch new_branch #创建新的分支（new_branch） #创建时会把当前分支的文件复制到新分支 git checkout new_branch #切换到new_branc分支 git checkout - #切换到之前的分支 git branc -m old_branch new_branch #更改分支的名字 #在新的分支上创建新文件，然后提交到git中 #在切换到分支中是不会有刚刚创建的文件的 git branch -d new_branch #删除new_branch分支，没有合并分支无法删除 #使用下面的命令可以强制删除 git branch -D new_branch git checkout -b new_branch #创建new_branch分支，并切换到新分支 git merge new_branch #将new_branch分支的修改内容合并到当前所在的分支 git branch -v #查看当前分支最近一次提交的信息 git远程操作 push 推送 pull 拉取，同时执行合并merge pull == fetch + merge #推送到GitHub #git remote 远程 #origin,表示用origin代替后面的地址 git remote add origin https://github.com/Kinvy66/NanoClock.git git push -u origin master #将本地的推送到远程，同时本地的master和远程的关联 #执行上述操作后，再次提交 git push git remote show #列出远程仓库的别名 git remote show origin #列出origin的详细信息 #ssh which ssh-keygen #查看keygen的目录 ssh-keygen #生成keygen #执行步骤 git remote add origin ssh地址 git push -u origin master ssh-keygen #将公钥配置到GitHub上 git push -u origin master 其他 使用 git add 后出现下面警告 warning: LF will be replaced by CRLF in text.txt. The file will have its original line endings in your working directory 警告：在xxx.xx文件中LF将被CRLF替换。 在你的工作区（working directory）里，这个文件将会保持它原本的换行符。（line ending:行尾，换行） CR：Carriage Return 回车\\r LF：Line Feed 换行 \\n CRLF：Carriage Return Line Feed 回车换行\\r\\n 出现原因： 这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。在git创建的项目中换行符为LF，而gits是linux环境，Git自作聪明的“换行符自动转换”功能会自动进行转换，然后系统会提示LF将被转换为CRLF。 解决的办法很简单，禁止git的自动转换即可。 ","date":"2021-02-21","objectID":"http://www.kinvystudio.cn/posts/git-user-manual/:1:0","tags":["Git"],"title":"Git 常用命令","uri":"http://www.kinvystudio.cn/posts/git-user-manual/"}]