[{"categories":["搭建博客"],"content":"Hugo+GitHub Page 搭建个人博客 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/hugo/:1:0","tags":["Hugo"],"title":"Hugo搭建博客","uri":"http://www.kinvystudio.cn/posts/hugo/"},{"categories":["搭建博客"],"content":"1. 下载安装Hugo 官方文档 安装方式 mkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended 直接下载EXE包安装 GitHub下载最新的Release包 解压包，将包的路径添加到环境变量 查看是否安装成功 hugo version #安装成功会显示hugo的版本 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/hugo/:1:1","tags":["Hugo"],"title":"Hugo搭建博客","uri":"http://www.kinvystudio.cn/posts/hugo/"},{"categories":["搭建博客"],"content":"2. 搭建博客 创建站点 hugo new site Blog #会在当前文件夹下创建出一个Blog文件夹 添加主题 Hugo不像Hexo是自带一个默认的主题，Hugo需要自己添加主题 主题下载 推荐主题LoveIt，将下载的主题放到 Blog/themes 文件夹下 将Blog目录下的config.toml 文件内容替换成主题文档提供的 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 同样在Blog目录下新建 config.yaml 文件，内容如下 ---baseurl:\"http://example.org/\"DefaultContentLanguage:\"zh-cn\"hasCJKLanguage:truelanguageCode:\"zh-cn\"title:\"Kinvy's 万事屋\"theme:\"LoveIt\" 添加文章 hugo new posts/my-first-post.md #在Blog路径下执行 生成的文章是在 /Blog/content/posts 下，使用Markdown编辑器打开编写内容 本地查看 hugo server -D 在浏览器输入给出的地址，即可查看 生成网页 hugo -D 生成静态网页，所有生成的网页文件在./public 文件夹下，同样部署到GitHub也是只要将这个文件夹push ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/hugo/:1:2","tags":["Hugo"],"title":"Hugo搭建博客","uri":"http://www.kinvystudio.cn/posts/hugo/"},{"categories":["搭建博客"],"content":"3. 部署到GitHub（Gitee） 创建仓库 仓库名一定要是==UserName.github.io== 其中UserName是GitHub的用户名，(下图中因为已经有该仓库，所以提示仓库名存在) 推送到GitHub 初始化本地仓库，注意：要在Blog/public下初始化 git init ​ git仓库的用户名和邮箱配置等步骤省略….. 注意：初始化仓库后要提交一次才可以关联远程仓库 关联远程仓库 git remote add origin https://github.com/Kinvy66/Kinvy66.github.io.git #关联远程仓库 git push -u origin master #第一次推送，同时跟踪远程分支 ​ 浏览 在浏览器地址栏输入 UserName,githu,io 就可以访问博客 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/hugo/:1:3","tags":["Hugo"],"title":"Hugo搭建博客","uri":"http://www.kinvystudio.cn/posts/hugo/"},{"categories":["搭建博客"],"content":"博客搭建 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/log/:1:0","tags":["Hugo"],"title":"Hugo博客搭建日志","uri":"http://www.kinvystudio.cn/posts/log/"},{"categories":["搭建博客"],"content":"TODO LIST 添加站内统计（包括字数，访问，运行时间等） 评论文本框右上角添加图片 文章显示摘要 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/log/:1:1","tags":["Hugo"],"title":"Hugo博客搭建日志","uri":"http://www.kinvystudio.cn/posts/log/"},{"categories":["搭建博客"],"content":"ISSUE 搜索系统无法工作 hugo删除文章 hugo自动文章的最后修改日期 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/log/:1:2","tags":["Hugo"],"title":"Hugo博客搭建日志","uri":"http://www.kinvystudio.cn/posts/log/"},{"categories":["搭建博客"],"content":"LOG 2021-04-17 添加建站日志 ","date":"2021-04-17","objectID":"http://www.kinvystudio.cn/posts/log/:1:3","tags":["Hugo"],"title":"Hugo博客搭建日志","uri":"http://www.kinvystudio.cn/posts/log/"},{"categories":["C++"],"content":"C++基础 C++中的基础语法与C基本一样，C++是包含C的所有语法的 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:1:0","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"1. 初识C++ Hello C++ #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello C++\" \u003c\u003c endl; system(\"pause\"); return 0; } c++中的关键字 asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:1:1","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"2. 数据类型 2.1 整型 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 实型（浮点型） 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 2.3 字符型 **作用：**字符型变量用于显示单个字符 语法：char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 2.4 字符串型 作用：用于表示一串字符 C风格字符串： char str[] = \"stringValue\" C++风格字符串： string str = \"stringValue\" 注意：C++风格字符串，需要加入头文件 ==#include \u003c string \u003e== 2.5 布尔类型 bool类型只有两个值： true —-真（本质是1） false —-假（本质是0） bool类型整1个字节大小 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:1:2","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"3. 运算符 算术运算符：+ - * / % ++(前后缀) -- (前后缀) 赋值运算符： = += -= *= /= %= 比较运算符：== != \u003c \u003e \u003c= \u003e= 逻辑运算符：! \u0026\u0026 || ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:1:3","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"程序流程结构 C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:2:0","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"1. 选择结构 if else : 包括多层嵌套 三目运算符： 表达式1 ? 表达式2 : 表达式3 switch 语句 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:2:1","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"2. 循环结构 while循环 do ... while 循环 for 循环 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:2:2","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"3. 跳转语句 break 语句，跳出当前循环或选择结构 continue 语句，在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 goto 语句，跳转至标号出执行，不建议使用 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:2:3","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"数组 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:3:0","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"1. 一维数组 一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:3:1","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"2. 二位数组(多维数组) 二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:3:2","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"函数 c++的函数和c的函数不同点 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:4:0","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"1. c++中的函数可以有默认参数 在c++中，函数的形参列表中的形参可以有默认值 语法： 返回值类型 函数名 (参数 = 默认值) {} 示例： int func(int a, int b = 10) { return a * b; } int main() { cout \u003c\u003c \"ret = \" \u003c\u003c func(10) \u003c\u003c endl; cout \u003c\u003c \"ret = \" \u003c\u003c func(10,2) \u003c\u003c endl; system(\"pause\"); return 0; } 注意： 默认参数必须放在参数列表的最后，调用时默认参数不传参使用默认的 传入参数，使用传入的实参 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:4:1","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"2. c++ 函数占位参数 c++中函数的形参列表里可以有占位参数，用来占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型) {} void func(int a, int) { cout \u003c\u003c \"this is func\" \u003c\u003c endl; } int main() { func(10, 10); //占位参数必须填补 system(\"pause\"); return 0; } ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:4:2","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"3. c++ 中函数可重载 函数重载的条件： 同一作用域下 函数名称相同 函数参数类型 或者 个数不同 或者 顺序不同 注意： 函数的返回值不可以作为函数重载的条件 示例： void func() { cout \u003c\u003c \"func()\" \u003c\u003c endl; } void func(int a) { cout \u003c\u003c \"func(int a)\" \u003c\u003c endl; } void func(double a) { cout \u003c\u003c \"func(double a)\" \u003c\u003c endl; } void func(int a, double b) { cout \u003c\u003c \"func(int a, double b)\" \u003c\u003c endl; } void func(double b, int a) { cout \u003c\u003c \"func(double a, int b)\" \u003c\u003c endl; } //函数返回值不可以作为函数重载条件 //int func(double b, int a) //{ // cout \u003c\u003c \"func(double a, int b)\" \u003c\u003c endl; // // return 0; //} int main() { func(); func(10); func(3.14); func(10, 3.14); func(3.14, 10); system(\"pause\"); return 0; } 函数重载碰到默认参数 void func(int a, int b = 10) { cout \u003c\u003c \"func(int a, int b = 10)\" \u003c\u003c endl; } void func(int a) { cout \u003c\u003c \"func(int a)\" \u003c\u003c endl; } int main() { int a = 10; //func(a); //错误，默认参数产生歧义 system(\"pause\"); return 0; } ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:4:3","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"指针 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:0","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"1. 基本概念 指针作用： 可以通过指针间接访问内存 内存编号从0开始记录的，一般用十六进制数字标识 可以用指针变量保存地址 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:1","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"2. 指定的定义 语法： 数据类型* 变量名 int main() { int a = 10; int* p; p = \u0026a; //p指向变量a的地址 cout \u003c\u003c \u0026a \u003c\u003c endl; //打印数据a的地址 cout \u003c\u003c p \u003c\u003c endl; //打印指针p的地址 cout \u003c\u003c \"*p\" \u003c\u003c *p \u003c\u003c endl; //通过*操作打印指针指向的地址的数据 system(\"pause\"); return 0; } 说明：所有指针类型在32位操作系统下是4个字节，在64位系统下是8个字节 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:2","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"3. 空指针和野指针 空指针： 指针变量指向内存编号为0的空间 用途： 初始化指针变量 注意： 空指针指向的内存是不可以访问的 示例： int main() { int* p = nullptr; cout \u003c\u003c *P \u003c\u003c endl; //程序运行异常，空指针指向的内存地址是不允许用户访问 system(\"pause\"); return 0; } 野指针： 指针变量指向非法内存空间 示例： int main() { int* p = (int*)0x1100; //访问野指针报错 cout \u003c\u003c *p \u003c\u003c endl; system(\"pause\"); return 0; } 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:3","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"4. const修饰指针 const修饰指针有三种情况： const修饰指针 — 常量指针 const修饰常量 — 指针常量 const既修饰指针又修饰常量 示例： int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int* p1 = \u0026a; p1 = \u0026b; //正确 //*p1 = 100; //错误 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int* const p2 = \u0026a; //p2 = \u0026b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int* const p3 = \u0026a; //p3 = \u0026b; //错误 //*p3 = 100; //错误 system(\"pause\"); return 0; } 技巧： 看const右侧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量 ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:4","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"5. 指针和数组 利用指针访问数组中元素，数组名就是数组的首地址 int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int* p = arr; cout \u003c\u003c \"第一个元素： \" \u003c\u003c arr[0] \u003c\u003c endl; cout \u003c\u003c \"指针访问第一个元素：\" \u003c\u003c *p \u003c\u003c endl; for (int i = 0; i \u003c 10; i++) { //利用指针遍历数组 cout \u003c\u003c *p \u003c\u003c endl; p++; } system(\"pause\"); return 0; } ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:5","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["C++"],"content":"6. 指针作函数参数 参入指针，可以修改实参的值 示例： //值传递 void swap1(int a, int b) { int temp = a; a = b; b = temp; } //地址传递 void swap2(int* p1, int* p2) { int temp = *p1; *p1 = *p2; *p2 = temp; } int main() { int a = 10; int b = 20; //值传递，不会改变实参 swap1(a, b); cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c endl; //地址传递，会改变实参 swap2(\u0026a, \u0026b); cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2021-03-08","objectID":"http://www.kinvystudio.cn/posts/cpp-base/:5:6","tags":["C++"],"title":"C++ 基础","uri":"http://www.kinvystudio.cn/posts/cpp-base/"},{"categories":["Java"],"content":"Java基础语法 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1. 注释、标识符、关键字 Java的注释有三种：(单行注释，多行注释) public class HelloWorld { public static void main(String[] args) { //1.单行注释 System.out.println(\"Hello,World!\"); /*2.多行 注释 */ //JavaDoc：文档注释 /** * @Description com.kinvy.base.HelloWorld * @Author Kinvy */ } } 标识符 关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符 标识符的规则：以字母，$,下划线开始，不能使用关键字或保留字 基本的命名规则和C/C++一致 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2. 数据类型 Java是强类型语言，即所有的变量必须先定义后才能使用 Java的数据类型分为两大类 基本类型 数值类型：整数类型(int shor byte long ),浮点型(float double) 字符类型(char 占两个字节) boolean类型 引用类型 类，接口，数组 说明：string 是类 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3类型转换 语法：(转换类型)变量名 public class HelloWorld { public static void main(String[] args) { char c1 = 'a'; System.out.println(c1); System.out.println(int(c1)); //char--\u003eint } } 低———————————————————————–高 byte -\u003e short -\u003e char -\u003e int -\u003e long -\u003e flaot -\u003e double 说明：强制转换可能存在精度丢失，自动转换（低–\u003e高） ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 常量、变量 命名规则： 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Person，GoodMan 方法名：首字母小写和驼峰原则：run() , startTask() 方法形参：下划线开始，首字母大写和驼峰原则： _Pos c++ ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5. 运算符 Java支持的运算符：常规运算符都支持 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"6. 包机制 包语句的语法格式： package pkg1[. pkg2[.pkg3..]] 导入包的语法： import package1[.package2..].classname|* package com.kinvy.array; //包 import java.util.Arrays; //导入Arrays的包 public class ArrayDemo01 { public static void main(String[] args) { int[] a = {1,2,3,4,9090,324,5412,122,3}; System.out.println(a); //打印数组元素 System.out.println(Arrays.toString((a))); } } 说明：一般利用公司域名倒置作为包名 com.baidu.www ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:1:6","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java流程控制（顺序，循环，选择） 参照C++流程控制语法 用户交互Scanner package com.kinvy.base; import java.util.Scanner; public class Demo02 { public static void main(String[] args) { //创建一个扫描器对象 Scanner scanner = new Scanner(System.in); System.out.println(\"使用next():\"); //判断用户有没有输入字符 if(scanner.hasNext()) { String str = scanner.next(); System.out.println(\"输出内容为：\"+str); } //scanner.close(); //用完管关掉，不关会一致占用资源 /**********************************/ scanner = new Scanner(System.in); System.out.println(\"使用nextline():\"); if(scanner.hasNextLine()) { String str1 = scanner.nextLine(); System.out.println(\"输出内容：\"+str1); } scanner.close(); int i = 0; System.out.println(\"输入整数：\"); if(scanner.hasNextInt()) { i = scanner.nextInt(); System.out.println(\"整数数据:\"+i); } else { System.out.println(\"输入的不是整数数据！\"); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:2:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java方法 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1.方法是什么 Java中的方法和C++中类的成员函数一致，用来完成特定功能的代码片段 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2.方法的定义 /* 修饰符 返回值类型 方法名（参数类型 参数名） { 方法体 return 返回值; } */ //方法是定义在class中的 public class Demo { public static void main(String[] args) { System.out.println(\"Hello,World!\"); int ret = add(10,20); //方法调用 System.out.println(ret); } //方法定义 public static int add(int num1,int num2) { return num1+num2; } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3.方法的重载 方法重载的规则： 方法名称必须相同 参数列表必须不同（个数不同，或类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不同 返回值类型不同不能作为重载的条件 public class Demo { public static void main(String[] args) { System.out.println(\"Hello,World!\"); int ret = add(10,20); //方法调用 System.out.println(ret); float f = add(1.2f,1.4f); System.out.println(f); } //方法定义 public static int add(int num1,int num2) { return num1+num2; } //重载方法 public static float add(float num1,float num2) { return num1+num2; } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 命令行传递参数 示例： //该程序需要在命令行运行 public class Demo01 { public static void main(String[] args) { for (int i = 0; i \u003c args.length; i++) { System.out.println(\"args[\"+i+\"]:\"+args[i]); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5.可变参数 JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 public class Demo02 { public static void main(String[] args) { Demo02 demo02 = new Demo02(); demo02.method(12,43,54,12,56,35); } public static void method(int... number) { System.out.println(number); //输出的是一个对象地址 for (int i = 0; i \u003c number.length; i++) { System.out.println(number[i]); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:3:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java OOP ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1. 初识面向对象 以类的形式组织代码，以对象的组织（封装）数据。 面向对象特征：封装，继承，多态 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2. 方法 定义一个 方法： 修饰符 返回值类型 方法名(…) { ​ 方法体 ​ return 返回值； } 示例： public class Demo01 { public static void main(String[] args) { //int max = max(129, 12); } public static String sayHello() { return \"hello\"; } public int max(int a, int b) { return a\u003eb ? a : b; } } 方法的调用 //Demo02.java public class Demo02 { public static void main(String[] args) { //非静态方法实例化这个类 Student student = new Student(); student.speak(); //静态方法 static Student.say(); } } //Student.java public class Student { //非静态方法 public void speak() { System.out.println(\"speak\"); } //静态方法 public static void say() { System.out.println(\"say\"); } } 说明：java方法的参数传递是值传递， ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"3. 对象的创建 使用new创建对象，示例同上 构造器 构造器和c++中的构造函数一致 无参构造，有参构造，定义了有参构造，无参构造必须显示定义 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:3","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"4. 面向对象三大特性 封装： 继承： Java只有单继承，没有多继承 在java中所有的类都默认直接或间接继承Object类 调用父类的同名属性和方法使用super 关键字 /************ Application.java **************/ package com.kinvy.oop; import com.kinvy.oop.demo02.Student; public class Application { public static void main(String[] args) { Student student = new Student(); student.test(\"App\"); } } /************* Person.java 父类 **************/ package com.kinvy.oop.demo02; //父类 Person public class Person { public Person() { } public String name = \"Person\"; } /********* Student.java 子类继承自Person ***********/ package com.kinvy.oop.demo02; //子类 继承自Person public class Student extends Person { //继承自Person public String name = \"Student\"; public void test(String name) { System.out.println(name); //输出的是传进来的name值 System.out.println(this.name); //输出当前类的name = Student System.out.println(super.name); //输出父类的name = Person } } 子类实例化时会自动调用父类的构造器，隐藏式的调用super()； super()注意点： super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或构造方法中 super和this不能同时调用构造方法 VS this 代表的对象不同： ​ this: 本身调用者这个对象 ​ super：代表父类对象的引用 前提： ​ this： 没有继承也可以使用 ​ super： 只能在继承条件才可以使用 构造方法： ​ this() ：本类的构造 ​ super()： 父类的构造 方法的重写 /************ Application.java **************/ package com.kinvy.oop; import com.kinvy.oop.demo02.Son; import com.kinvy.oop.demo02.Base; public class Application { public static void main(String[] args) { Son son = new Son(); Base base = new Son(); //静态方法 son.test01(); //调用子类 base.test01(); //调用父类 System.out.println(\"------------------\"); //非静态方法 son.test02(); //调用子类 base.test02(); //调用父类 } } /************* Base.java 父类 **************/ package com.kinvy.oop.demo02; public class Base { public static void test01() { System.out.println(\"Base test01()\"); } public void test02() { System.out.println(\"Base test02()\"); } } /********* Son.java 子类继承自Person ***********/ package com.kinvy.oop.demo02; public class Son extends Base{ public static void test01() { //静态无法重写 System.out.println(\"Son test01()\"); } @Override //重写父类非静态方法 public void test02() { System.out.println(\"Son test02()\"); } } 重写：需要有继承关系，子类重写父类的方法 方法名必须相同 参数列表必须相同 修饰符：权限范围可以扩大 但不能缩小 publi-\u003eprotected-\u003eprivate 抛出的异常：范围，可以被缩小，但不能扩大 多态： /************Application.java ******************/ package com.kinvy.oop; import com.kinvy.oop.demo03.Person; import com.kinvy.oop.demo03.Student; public class Application { public static void main(String[] args) { //一个对象的实际类型是确定的 new Student(); new Person(); //可以指向的引用类型就不确定了；父类的引用指向子类 //Student 能调用的方法都是自己的或者继承父类的 Student s1 = new Student(); //Person 父类型， 可以指向子类，当时不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); s2.run(); //子类重写了父类的方法，执行子类的方法 s1.run(); ((Student) s2).eat(); //强制装换 } } /************Person,java*************************/ package com.kinvy.oop.demo03; public class Person { public void run() { System.out.println(\"person run\"); } } /************Student.java*********************/ package com.kinvy.oop.demo03; public class Student extends Person { @Override public void run() { System.out.println(\"student run\"); } public void eat() { System.out.println(\"student eat\"); } } 多态注意事项： 多态是方法的多态，属性没有多态 父类和子类，有联系，类型转换异常 ！ ClassCast 存在条件：继承关系，方法需要重写，父类引用指向子类对象！ father f1 = new son(); ​ 不可以重写的方法： static方法 final常量 private方法 instanceof 关键字 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:4","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"5. 抽象类和接口 抽象类 Java的抽象类和C++的抽象类大致差不多 关键词 abstact修饰 package com.kinvy.oop.demo04; public abstract class Action { //抽象类 //约束~有人帮我们实现 //abstract 抽象方法，只有方法名字，没有方法的实现 //对应c++的纯虚函数 public abstract void doSomething(); //1.不能new这个抽象类，只能靠子类去实现它； //2.抽象类中可以写普通方法 //3.抽象方法必须在抽象类中 } 接口： 接口声明关键词 interface /************** UserService.java**********/ //接口 package com.kinvy.oop.demo05; //interface 定义的关键字，接口都学要有实现类 public interface UserService { //常量 public static final int AGE = 10; //接口中的所有定义其实都是抽象的 public abstract void add(String name); void delete(String name); void update(String name); void query(String name); } /************** TimeService.java**********/ //接口 package com.kinvy.oop.demo05; public interface TimeService { void timer(); } package com.kinvy.oop.demo05; public interface TimeService { void timer(); } package com.kinvy.oop.demo05; public interface TimeService { void timer(); } /************** UserSevviceImpl.java**********/ package com.kinvy.oop.demo05; //类 可以实现接口 //实现了接口中的 //多继承~利用接口实现多继承 public class UserSevviceImpl implements UserService,TimeService { @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } @Override public void timer() { } } 接口作用： 约束 定义一些方法，让不同人实现 接的方法是 public abstract , 属性是 public static final 接口不能被实例化，接口没有构造方法 implents可以实现多个接口 必须要重写接口中的方法 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:5","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"6.内部类及OOP实战 类中类 /************** Application.java**********/ package com.kinvy.oop; import com.kinvy.oop.demo06.Outer; public class Application { public static void main(String[] args) { Outer outer = new Outer(); //通过这个外部类来实例化内部类 Outer.Inner inner = outer.new Inner(); inner.getID(); } } /************** Outer.java**********/ package com.kinvy.oop.demo06; public class Outer { private int id = 10; public void out() { System.out.println(\"out\"); } public class Inner { public void in() { System.out.println(\"in\"); } //获得外部类的私有属性 public void getID() { System.out.println(id); } } } ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:4:6","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"Java 异常 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:5:0","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"1.什么是异常 程序运行出现不可预见的情况 Java把异常当作对象来处理 ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:5:1","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["Java"],"content":"2. Java异常处理机制 抛出异常 捕获异常 异常处理关键字： try catch finally throw throws package com.kinvy.exception; public class Demo01 { public static void main(String[] args) { int a = 1; int b = 0; //捕获多个异常，要从小到大 try { //try 监控区域 System.out.println(a/b); }catch (Error e) { //catch（想要捕获的异常类型） 捕获异常 System.out.println(\"Error\"); }catch (Exception e) { System.out.println(\"Exception\"); }catch (Throwable e){ System.out.println(\"Throwable\"); }finally { //finally 可选 处理后事 System.out.println(\"finally\"); } //方法抛出异常 try { new Demo01().test(a,b); } catch (ArithmeticException e) { e.printStackTrace(); } } //假设这个方法中，处理不了这个异常。方法抛出异常 public void test(int a, int b) throws ArithmeticException{ if(b == 0) { throw new ArithmeticException(); //主动抛出异常，一般在方法中使用 } } } 捕获多个异常，要从小到大 ，IDEA快捷键 Ctrl + Alt + T ","date":"2021-02-24","objectID":"http://www.kinvystudio.cn/posts/javabase/:5:2","tags":["java"],"title":"Java基础","uri":"http://www.kinvystudio.cn/posts/javabase/"},{"categories":["git"],"content":"Typora+PicGo实现笔记图片上传到服务器,上传失败 Typora+PicGo实现笔记中图片上传到服务器，避免Markdown文件拷贝时图片打不开的问题 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:0:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"软件工具 系统：Windows10（macOS请参考 官方文档） Typora（版本：≥ 0.9.9.32 on macOS or 0.9.84 on Windows / Linux） PicGo（版本：≥ 2.2.0 ),在Typora软件下载（文件–\u003e偏好设置–\u003e图像） 阿里云OSS对象，（使用gitee或GitHub也可以） ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:1:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"阿里云OSS的购买和使用 购买阿里云OSS，我购买的是40GB一年的（9RMB） 在控制台找到OSS管理，创建Bucket，读写权限设置为公共读，名称按照规定任意写一个，其他设置默认就可以 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:2:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"配置PicGO 打开PicGo配置阿里云OSS 设定KeyId：在阿里云的控制台中，如下图1，没有AccessKey ID 的话可以自己创建一个，然后将 AccessKey ID 复制道KeyId 设定KeySecret：在创建的AccessKey ID中查看Secret，把它复制到设定KeySecret 设定存储空间名：Bucket的名称 确认存储区域：阿里云控制台中，图2 图1：图2： 配置PicGo的端口36677 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:3:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["git"],"content":"Typora设置 文件–\u003e偏好设置–\u003e图像， 设置如下图 设置完毕，将图片添加到Markdown笔记中，会自动上传到服务器，图片链接也会转成一个URL 注意：PicGo的端口一定要设置正确，否则图片会上传失败 ","date":"2021-02-23","objectID":"http://www.kinvystudio.cn/posts/typora+picgo/:4:0","tags":["Markdown","oss"],"title":"Typora+PicGo实现笔记图片上传到服务器遇到的问题","uri":"http://www.kinvystudio.cn/posts/typora+picgo/"},{"categories":["Git"],"content":"Git的基本使用 基本命令 git init #初始化当前文件夹作为git库 git clone #复制远程的库 #版本管理 git add #将工作区的文件放入暂存区，后面加文件名或文件 git commit #将暂存区的文件提交到库中，会弹出编辑器提示输入提交信息，适用于提交信息比较多的情况 git commit -m '提交信息' #提交文件到库中，并注明提价信息，适用提交信息比较简短的情况 git rm #删除文件 git rm --cached \u003cfile\u003e... #从暂存区删除文件 #查看信息 git help #帮助 git log #查看日志 git log -n #查看最近n条的日志 git log --pretty=oneline #一行简略的显示日志 git diff #比较不同 git status #查看文件修改状态 git config --list #查看配置信息 #远程协作 git pull git push #git配置 git config --global #使用全局配置文件 git config --system #使用系统的配置文件 git config --local #使用当前仓库的配置文件 git config --global user.name 'naem' #配置全局用户名 git config --global user.email 'email' #配置全局邮箱 #删除文件 git rm filename #删除工作区的文件， #完成了两件事，1.删除一个文件 2.将删除的文件纳入到暂存区 #从已提交的文件中恢复删除的文件 git reset HEAD filename #将待删除的文件从暂存区恢复到工作区 git checkout -- filename #把之前的修改丢弃，用 rm 删除的文件只要这个命令就可以恢复 #文件重命名 git mv oldname newname #执行这个命令后文件就会放入到暂存区，和mv的区别与 git rm和rm的区别一样 #修改上次提交的消息 git commit --amend -m '修改的消息内容' #.gitignore文件 #在目录下添加一个.gitignore文件 #文件内容就是需要忽略文件的文件名 #git上传是就会忽略这些文件 #文件支持通配符和正则表达式 分支相关命令 git branch #查看当前所有的分支 git branch new_branch #创建新的分支（new_branch） #创建时会把当前分支的文件复制到新分支 git checkout new_branch #切换到new_branc分支 git checkout - #切换到之前的分支 git branc -m old_branch new_branch #更改分支的名字 #在新的分支上创建新文件，然后提交到git中 #在切换到分支中是不会有刚刚创建的文件的 git branch -d new_branch #删除new_branch分支，没有合并分支无法删除 #使用下面的命令可以强制删除 git branch -D new_branch git checkout -b new_branch #创建new_branch分支，并切换到新分支 git merge new_branch #将new_branch分支的修改内容合并到当前所在的分支 git branch -v #查看当前分支最近一次提交的信息 git远程操作 push 推送 pull 拉取，同时执行合并merge pull == fetch + merge #推送到GitHub #git remote 远程 #origin,表示用origin代替后面的地址 git remote add origin https://github.com/Kinvy66/NanoClock.git git push -u origin master #将本地的推送到远程，同时本地的master和远程的关联 #执行上述操作后，再次提交 git push git remote show #列出远程仓库的别名 git remote show origin #列出origin的详细信息 #ssh which ssh-keygen #查看keygen的目录 ssh-keygen #生成keygen #执行步骤 git remote add origin ssh地址 git push -u origin master ssh-keygen #将公钥配置到GitHub上 git push -u origin master 版本回退 方法一： 查看提交历史，确定回退版本 git log 回退到某个版本 git reset --hard [版本号，只需前几个字符就可以] 强制提交到远程 git push -f -u origin master 注意：回退之后强制提交到远程，回退版本之后的提交历史会没有的。 方法二：git revert git revert HEAD #撤销前一次commit git revert HEAD^ #撤销前前一次 commit git revert commit [commit id] #撤销指定版本 git revert 是提交一个新的版本，这个新版本是将revert的版本内容反向修改， 版本会递增，不会影响之前提交的内容 其他 使用 git add 后出现下面警告 warning: LF will be replaced by CRLF in text.txt. The file will have its original line endings in your working directory 警告：在xxx.xx文件中LF将被CRLF替换。 在你的工作区（working directory）里，这个文件将会保持它原本的换行符。（line ending:行尾，换行） CR：Carriage Return 回车\\r LF：Line Feed 换行 \\n CRLF：Carriage Return Line Feed 回车换行\\r\\n 出现原因： 这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。在git创建的项目中换行符为LF，而gits是linux环境，Git自作聪明的“换行符自动转换”功能会自动进行转换，然后系统会提示LF将被转换为CRLF。 解决的办法很简单，禁止git的自动转换即可。 ","date":"2021-02-21","objectID":"http://www.kinvystudio.cn/posts/git-user-manual/:1:0","tags":["Git"],"title":"Git 常用命令","uri":"http://www.kinvystudio.cn/posts/git-user-manual/"}]